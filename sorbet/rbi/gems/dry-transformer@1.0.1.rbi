# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-transformer` gem.
# Please instead update this file by running `bin/tapioca gem dry-transformer`.


# source://dry-transformer//lib/dry/transformer/constants.rb#3
module Dry
  class << self
    # source://dry-core/1.1.0/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # source://dry-struct/1.7.1/lib/dry/struct.rb#30
    def Struct(attributes = T.unsafe(nil), &block); end

    # source://dry-types/1.8.2/lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# source://dry-transformer//lib/dry/transformer/constants.rb#4
module Dry::Transformer
  class << self
    # @api public
    # @see Pipe.[]
    #
    # source://dry-transformer//lib/dry/transformer.rb#12
    def [](registry); end

    # @api private
    #
    # source://dry-transformer//lib/dry/transformer.rb#17
    def loader; end
  end
end

# Transformation functions for Array objects
#
# @api public
# @example
#   require 'dry/transformer/array'
#
#   include Dry::Transformer::Helper
#
#   fn = t(:map_array, t(:symbolize_keys)) >> t(:wrap, :address, [:city, :zipcode])
#
#   fn.call(
#   [
#   { 'city' => 'Boston', 'zipcode' => '123' },
#   { 'city' => 'NYC', 'zipcode' => '312' }
#   ]
#   )
#   # => [{:address=>{:city=>"Boston", :zipcode=>"123"}}, {:address=>{:city=>"NYC", :zipcode=>"312"}}]
#
# source://dry-transformer//lib/dry/transformer/array_transformations.rb#23
module Dry::Transformer::ArrayTransformations
  extend ::Dry::Transformer::Registry

  class << self
    # Adds missing keys with nil value to all tuples in array
    #
    # @api public
    # @param keys [Array]
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#173
    def add_keys(array, keys); end

    # @api public
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#121
    def combine(array, mappings); end

    # Converts the array of hashes to array of values, extracted by given key
    #
    # @api public
    # @example
    #   fn = t(:extract_key, :name)
    #   fn.call [
    #   { name: 'Alice', role: 'sender' },
    #   { name: 'Bob', role: 'receiver' },
    #   { role: 'listener' }
    #   ]
    #   # => ['Alice', 'Bob', nil]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#142
    def extract_key(array, key); end

    # Group array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Dry::Transformer(:group, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    #   # => [{ task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }]]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#82
    def group(array, key, keys); end

    # Wraps every value of the array to tuple with given key
    #
    # The transformation partially inverses the `extract_key`.
    #
    # @api public
    # @example
    #   fn = t(:insert_key, 'name')
    #   fn.call ['Alice', 'Bob', nil]
    #   # => [{ 'name' => 'Alice' }, { 'name' => 'Bob' }, { 'name' => nil }]
    # @param array [Array<Hash>] The input array of hashes
    # @param key [Object] The key to extract values by
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#161
    def insert_key(array, key); end

    # Map array values using transformation function
    #
    # @api public
    # @example
    #
    #   fn = Dry::Transformer(:map_array, -> v { v.upcase })
    #
    #   fn.call ['foo', 'bar'] # => ["FOO", "BAR"]
    # @param array [Array] The input array
    # @param fn [Proc] The transformation function
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#40
    def map_array(array, fn); end

    # Ungroup array values using provided root key and value keys
    #
    # @api public
    # @example
    #   fn = Dry::Transformer(:ungroup, :tags, [:tag])
    #
    #   fn.call [
    #   { task: 'Group it', tags: [{ tag: 'task' }, { tag: 'important' }] }
    #   ]
    #   # => [
    #   { task: 'Group it', tag: 'task' },
    #   { task: 'Group it', tag: 'important' }
    #   ]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#117
    def ungroup(array, key, keys); end

    # Wrap array values using HashTransformations.nest function
    #
    # @api public
    # @example
    #   fn = Dry::Transformer(:wrap, :address, [:city, :zipcode])
    #
    #   fn.call [{ city: 'NYC', zipcode: '123' }]
    #   # => [{ address: { city: 'NYC', zipcode: '123' } }]
    # @param array [Array] The input array
    # @param key [Object] The nesting root key
    # @param keys [Object] The nesting value keys
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/array_transformations.rb#59
    def wrap(array, key, keys); end
  end
end

# source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#6
class Dry::Transformer::ArrayTransformations::Combine
  class << self
    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#10
    def combine(array, mappings); end

    private

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#24
    def add_groups_to_element(element, groups, mappings); end

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#32
    def element_candidates(element, candidates, keys); end

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#56
    def element_candidates_key(element, keys); end

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#43
    def group_candidates(candidates, mapping); end

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#49
    def group_candidates_by_keys(candidates, keys); end

    # source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#36
    def group_nodes(nodes, mappings); end
  end
end

# source://dry-transformer//lib/dry/transformer/array_transformations/combine.rb#7
Dry::Transformer::ArrayTransformations::Combine::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# Transformation functions for Classes
#
# @api public
# @example
#   require 'dry/transformer/class'
#
#   include Dry::Transformer::Helper
#
#   fn = t(:constructor_inject, Struct)
#
#   fn['User', :name, :age]
#   # => Struct::User
#
# source://dry-transformer//lib/dry/transformer/class_transformations.rb#18
module Dry::Transformer::ClassTransformations
  extend ::Dry::Transformer::Registry

  class << self
    # Inject given arguments into the constructor of the class
    #
    # @api public
    # @example
    #   Transproct(:constructor_inject, Struct)['User', :name, :age]
    #   # => Struct::User
    # @param A [*Mixed] list of arguments to inject
    # @return [Object] An instance of the given klass
    #
    # source://dry-transformer//lib/dry/transformer/class_transformations.rb#32
    def constructor_inject(*args, klass); end

    # Set instance variables from the hash argument (key/value pairs) on the object
    #
    # @api public
    # @example
    #   Dry::Transformer(:set_ivars, Object)[name: 'Jane', age: 25]
    #   # => #<Object:0x007f411d06a210 @name="Jane", @age=25>
    # @param [Object]
    # @return [Object]
    #
    # source://dry-transformer//lib/dry/transformer/class_transformations.rb#47
    def set_ivars(ivar_hash, klass); end
  end
end

# Coercion functions for common types
#
# @api public
#
# source://dry-transformer//lib/dry/transformer/coercions.rb#13
module Dry::Transformer::Coercions
  extend ::Dry::Transformer::Registry

  class << self
    # Does nothing and returns a value
    #
    # @api public
    # @example
    #   fn = Coercions[:identity]
    #   fn[:foo] # => :foo
    # @param value [Object]
    # @return [Object]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#34
    def identity(value = T.unsafe(nil)); end

    # Coerce value into a boolean
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_boolean)['true']
    #   # => true
    #   Dry::Transformer(:to_boolean)['f']
    #   # => false
    # @param value [Object] The input value
    # @return [TrueClass, FalseClass]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#126
    def to_boolean(value); end

    # Coerce value into a date
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_date)['2015-04-14']
    #   # => #<Date: 2015-04-14 ((2457127j,0s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [Date]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#141
    def to_date(value); end

    # Coerce value into a datetime
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_datetime)['2015-04-14 12:01:45']
    #   # => #<DateTime: 2015-04-14T12:01:45+00:00 ((2457127j,43305s,0n),+0s,2299161j)>
    # @param value [Object] The input value
    # @return [DateTime]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#171
    def to_datetime(value); end

    # Coerce value into a decimal
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_decimal)[1.2]
    #   # => #<BigDecimal:7fca32acea50,'0.12E1',18(36)>
    # @param value [Object] The input value
    # @return [Decimal]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#109
    def to_decimal(value); end

    # Coerce value into a float
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_float)['1.2']
    #   # => 1.2
    # @param value [Object] The input value
    # @return [Float]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#94
    def to_float(value); end

    # Coerce value into a integer
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_integer)['1']
    #   # => 1
    # @param value [Object] The input value
    # @return [Integer]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#79
    def to_integer(value); end

    # Coerce value into a string
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_string)[1]
    #   # => "1"
    # @param value [Object] The input value
    # @return [String]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#49
    def to_string(value); end

    # Coerce value into a symbol
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_symbol)['foo']
    #   # => :foo
    # @param value [#to_s] The input value
    # @return [Symbol]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#64
    def to_symbol(value); end

    # Coerce value into a time
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_time)['2015-04-14 12:01:45']
    #   # => 2015-04-14 12:01:45 +0200
    # @param value [Object] The input value
    # @return [Time]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#156
    def to_time(value); end

    # Coerce value into an array containing tuples only
    #
    # If the source is not an array, or doesn't contain a tuple, returns
    # an array with one empty tuple
    #
    # @api public
    # @example
    #   Dry::Transformer(:to_tuples)[:foo]                  # => [{}]
    #   Dry::Transformer(:to_tuples)[[]]                    # => [{}]
    #   Dry::Transformer(:to_tuples)[[{ foo: :FOO, :bar }]] # => [{ foo: :FOO }]
    # @param value [Object]
    # @return [Array<Hash>]
    #
    # source://dry-transformer//lib/dry/transformer/coercions.rb#189
    def to_tuples(value); end
  end
end

# @api public
#
# source://dry-transformer//lib/dry/transformer/coercions.rb#19
Dry::Transformer::Coercions::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-transformer//lib/dry/transformer/coercions.rb#17
Dry::Transformer::Coercions::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-transformer//lib/dry/transformer/coercions.rb#16
Dry::Transformer::Coercions::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://dry-transformer//lib/dry/transformer/compiler.rb#6
class Dry::Transformer::Compiler
  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#11
  def initialize(registry, transformer = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#16
  def call(ast); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#9
  def registry; end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#9
  def transformer; end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#20
  def visit(node); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#38
  def visit_arg(arg); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#25
  def visit_fn(node); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/compiler.rb#42
  def visit_t(node); end
end

# @api private
#
# source://dry-transformer//lib/dry/transformer/compiler.rb#7
class Dry::Transformer::Compiler::InvalidFunctionNameError < ::StandardError; end

# Composition of two functions
#
# @api private
#
# source://dry-transformer//lib/dry/transformer/composite.rb#8
class Dry::Transformer::Composite
  # @api private
  # @return [Composite] a new instance of Composite
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#20
  def initialize(left, right); end

  # @api public
  # @see Function#compose
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#40
  def +(other); end

  # @api public
  # @see Function#compose
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#40
  def >>(other); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#32
  def [](value); end

  # Call right side with the result from the left side
  #
  # @api public
  # @param value [Object] The input value
  # @return [Object]
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#32
  def call(value); end

  # @api public
  # @see Function#compose
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#40
  def compose(other); end

  # @api private
  # @return [Proc]
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#12
  def left; end

  # @api private
  # @return [Proc]
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#17
  def right; end

  # @api public
  # @see Function#to_ast
  #
  # source://dry-transformer//lib/dry/transformer/composite.rb#49
  def to_ast; end
end

# Conditional transformation functions
#
# @api public
# @example
#   require 'dry/transformer/conditional'
#
#   include Dry::Transformer::Helper
#
#   fn = t(:guard, -> s { s.is_a?(::String) }, -> s { s.to_sym })
#
#   [fn[2], fn['Jane']]
#   # => [2, :Jane]
#
# source://dry-transformer//lib/dry/transformer/conditional.rb#18
module Dry::Transformer::Conditional
  extend ::Dry::Transformer::Registry

  class << self
    # Apply the transformation function to subject if the predicate returns true, or return un-modified
    #
    # @api public
    # @example
    #   [2, 'Jane'].map do |subject|
    #   Dry::Transformer(:guard, -> s { s.is_a?(::String) }, -> s { s.to_sym })[subject]
    #   end
    #   # => [2, :Jane]
    # @param [Mixed]
    # @return [Mixed]
    #
    # source://dry-transformer//lib/dry/transformer/conditional.rb#51
    def guard(value, predicate, fn); end

    # Calls a function when type-check passes
    #
    # @api public
    # @example
    #   fn = Dry::Transformer(:is, Array, -> arr { arr.map(&:upcase) })
    #   fn.call(['a', 'b', 'c']) # => ['A', 'B', 'C']
    #
    #   fn = Dry::Transformer(:is, Array, -> arr { arr.map(&:upcase) })
    #   fn.call('foo') # => "foo"
    # @param [Object]
    # @param [Class]
    # @param [Proc]
    # @return [Object]
    #
    # source://dry-transformer//lib/dry/transformer/conditional.rb#71
    def is(value, type, fn); end

    # Negates the result of transformation
    #
    # @api public
    # @example
    #   fn = Conditional[:not, -> value { value.is_a? ::String }]
    #   fn[:foo]  # => true
    #   fn["foo"] # => false
    # @param value [Object]
    # @param fn [Proc]
    # @return [Boolean]
    #
    # source://dry-transformer//lib/dry/transformer/conditional.rb#34
    def not(value, fn); end
  end
end

# source://dry-transformer//lib/dry/transformer/error.rb#5
class Dry::Transformer::Error < ::StandardError; end

# Transformation proc wrapper allowing composition of multiple procs into
# a data-transformation pipeline.
#
# This is used by Dry::Transformer to wrap registered methods.
#
# @api private
#
# source://dry-transformer//lib/dry/transformer/function.rb#11
class Dry::Transformer::Function
  # @api private
  # @return [Function] a new instance of Function
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#34
  def initialize(fn, options = T.unsafe(nil)); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#61
  def +(other); end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#77
  def ==(other); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#61
  def >>(other); end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#47
  def [](*value); end

  # Additional arguments that will be passed to the wrapped proc
  #
  # @api private
  # @return [Array]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#24
  def args; end

  # Call the wrapped proc
  #
  # @api public
  # @param value [Object] The input value
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#47
  def call(*value); end

  # Compose this function with another function or a proc
  #
  # @api public
  # @param [Proc, Function]
  # @return [Composite]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#61
  def compose(other); end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#77
  def eql?(other); end

  # Wrapped proc or another composite function
  #
  # @api private
  # @return [Proc, Composed]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#17
  def fn; end

  # @api public
  # @return [<type] The name of the function] <type] The name of the function
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#31
  def name; end

  # Return a simple AST representation of this function
  #
  # @api public
  # @return [Array]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#89
  def to_ast; end

  # Converts a transproc to a simple proc
  #
  # @api private
  # @return [Proc]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#98
  def to_proc; end

  # Return a new fn with curried args
  #
  # @api private
  # @return [Function]
  #
  # source://dry-transformer//lib/dry/transformer/function.rb#72
  def with(*args); end
end

# source://dry-transformer//lib/dry/transformer/error.rb#6
class Dry::Transformer::FunctionAlreadyRegisteredError < ::Dry::Transformer::Error; end

# source://dry-transformer//lib/dry/transformer/error.rb#8
class Dry::Transformer::FunctionNotFoundError < ::Dry::Transformer::Error
  # @return [FunctionNotFoundError] a new instance of FunctionNotFoundError
  #
  # source://dry-transformer//lib/dry/transformer/error.rb#9
  def initialize(function, source = T.unsafe(nil)); end
end

# Transformation functions for Hash objects
#
# @api public
# @example
#   require 'dry/transformer/hash'
#
#   include Dry::Transformer::Helper
#
#   fn = t(:symbolize_keys) >> t(:nest, :address, [:street, :zipcode])
#
#   fn["street" => "Street 1", "zipcode" => "123"]
#   # => {:address => {:street => "Street 1", :zipcode => "123"}}
#
# source://dry-transformer//lib/dry/transformer/hash_transformations.rb#18
module Dry::Transformer::HashTransformations
  extend ::Dry::Transformer::Registry

  class << self
    # Accepts specified keys from a hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:accept_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:name=>"Jane"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be accepted
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#208
    def accept_keys(hash, keys); end

    # Copy all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:copy_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:user_name => "Jane", :name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-copy mapping
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#170
    def copy_keys(source_hash, mapping); end

    # Merge a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => { 'one' => 1 } }
    #   other = { 'foo' => 'buz', 'baz' => { :one => 'one', :two => 2 } }
    #
    #   t(:deep_merge)[input, other]
    #   # => { 'foo' => "buz", :baz => { :one => 'one', 'one' => 1, :two => 2 } }
    # @param [Hash]
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#418
    def deep_merge(hash, other); end

    # Stringify keys in a hash recursively
    #
    # @api public
    # @example
    #   input = { :foo => "bar", :baz => [{ :one => 1 }] }
    #
    #   t(:deep_stringify_keys)[input]
    #   # => { "foo" => "bar", "baz" => [{ "one" => 1 }] }
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#109
    def deep_stringify_keys(hash); end

    # Symbolize keys in a hash recursively
    #
    # @api public
    # @example
    #
    #   input = { 'foo' => 'bar', 'baz' => [{ 'one' => 1 }] }
    #
    #   t(:deep_symbolize_keys)[input]
    #   # => { :foo => "bar", :baz => [{ :one => 1 }] }
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#65
    def deep_symbolize_keys(hash); end

    # Recursively evaluate hash values if they are procs/lambdas
    #
    # @api public
    # @example
    #   hash = {
    #   num: -> i { i + 1 },
    #   str: -> i { "num #{i}" }
    #   }
    #
    #   t(:eval_values, 1)[hash]
    #   # => {:num => 2, :str => "num 1" }
    #
    #   # with filters
    #   t(:eval_values, 1, [:str])[hash]
    #   # => {:num => #{still a proc}, :str => "num 1" }
    # @param [Hash]
    # @param args [Array, Object] Anything that should be passed to procs
    # @param filters [Array] A list of attribute names that should be evaluated
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#380
    def eval_values(hash, args, filters = T.unsafe(nil)); end

    # Folds array of tuples to array of values from a specified key
    #
    # @api public
    # @example
    #   source = {
    #   name: "Jane",
    #   tasks: [{ title: "be nice", priority: 1 }, { title: "sleep well" }]
    #   }
    #   Dry::Transformer(:fold, :tasks, :title)[source]
    #   # => { name: "Jane", tasks: ["be nice", "sleep well"] }
    #   Dry::Transformer(:fold, :tasks, :priority)[source]
    #   # => { name: "Jane", tasks: [1, nil] }
    # @param hash [Hash]
    # @param key [Object] The key to fold values to
    # @param tuple_key [Object] The key to take folded values from
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#315
    def fold(hash, key, tuple_key); end

    # Map all keys in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Dry::Transformer(:map_keys, -> s { s.upcase })['name' => 'Jane']
    #   # => {"NAME" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#32
    def map_keys(source_hash, fn); end

    # Map a key in a hash with the provided transformation function
    #
    # @api public
    # @example
    #   Dry::Transformer(:map_value, 'name', -> s { s.upcase })['name' => 'jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#223
    def map_value(hash, key, fn); end

    # Map all values in a hash using transformation function
    #
    # @api public
    # @example
    #   Dry::Transformer(:map_values, -> v { v.upcase })[:name => 'Jane']
    #   # => {"name" => "JANE"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#136
    def map_values(source_hash, fn); end

    # Nest values from specified keys under a new key
    #
    # @api public
    # @example
    #   Dry::Transformer(:nest, :address, [:street, :zipcode])[street: 'Street', zipcode: '123']
    #   # => {address: {street: "Street", zipcode: "123"}}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#238
    def nest(hash, root, keys); end

    # Rejects specified keys from a hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:reject_keys, [:name])[name: 'Jane', email: 'jane@doe.org']
    #   # => {:email => "jane@doe.org"}
    # @param hash [Hash] The input hash
    # @param keys [Array] The keys to be rejected
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#192
    def reject_keys(hash, keys); end

    # Rename all keys in a hash using provided mapping hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:rename_keys, user_name: :name)[user_name: 'Jane']
    #   # => {:name => "Jane"}
    # @param source_hash [Hash] The input hash
    # @param mapping [Hash] The key-rename mapping
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#152
    def rename_keys(source_hash, mapping); end

    # Splits hash to array by all values from a specified key
    #
    # The operation adds missing keys extracted from the array to regularize the output.
    #
    # @api public
    # @example
    #   input = {
    #   name: 'Joe',
    #   tasks: [
    #   { title: 'sleep well', priority: 1 },
    #   { title: 'be nice',    priority: 2 },
    #   {                      priority: 2 },
    #   { title: 'be cool'                 }
    #   ]
    #   }
    #   Dry::Transformer(:split, :tasks, [:priority])[input]
    #   => [
    #   { name: 'Joe', priority: 1,   tasks: [{ title: 'sleep well' }]              },
    #   { name: 'Joe', priority: 2,   tasks: [{ title: 'be nice' }, { title: nil }] },
    #   { name: 'Joe', priority: nil, tasks: [{ title: 'be cool' }]                 }
    #   ]
    # @param hash [Hash]
    # @param key [Object] The key to split a hash by
    # @param subkeys [Array] The list of subkeys to be extracted from key
    # @return [Array<Hash>]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#347
    def split(hash, key, keys); end

    # Stringify all keys in a hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:stringify_keys)[:name => 'Jane']
    #   # => {"name" => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#92
    def stringify_keys(hash); end

    # Symbolize all keys in a hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:symbolize_keys)['name' => 'Jane']
    #   # => {:name => "Jane"}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#47
    def symbolize_keys(hash); end

    # Collapse a nested hash from a specified key
    #
    # @api public
    # @example
    #   Dry::Transformer(:unwrap, :address, [:street, :zipcode])[address: { street: 'Street', zipcode: '123' }]
    #   # => {street: "Street", zipcode: "123"}
    # @option options
    # @param source_hash [Hash]
    # @param root [Mixed] The root key to unwrap values from
    # @param selected [Array] The keys that should be unwrapped (optional)
    # @param options [Hash] hash of options (optional)
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/hash_transformations.rb#276
    def unwrap(source_hash, root, selected = T.unsafe(nil), prefix: T.unsafe(nil)); end
  end
end

# Pipe class for defining transprocs with a class DSL.
#
# @api public
# @example
#   require 'anima'
#   require 'dry/transformer/all'
#
#   class User
#   include Anima.new(:name, :address)
#   end
#
#   class Address
#   include Anima.new(:city, :street, :zipcode)
#   end
#
#   class UsersMapper < Dry::Transformer::Pipe
#   map_array do
#   symbolize_keys
#   rename_keys user_name: :name
#   nest :address, %i(city street zipcode)
#   map_value :address do
#   constructor_inject Address
#   end
#   constructor_inject User
#   end
#   end
#
#   UsersMapper.new.call(
#   [
#   { 'user_name' => 'Jane',
#   'city' => 'NYC',
#   'street' => 'Street 1',
#   'zipcode' => '123'
#   }
#   ]
#   )
#   # => [
#   #<User
#   name="Jane"
#   address=#<Address city="NYC" street="Street 1" zipcode="123">>
#   ]
#
# source://dry-transformer//lib/dry/transformer/pipe.rb#47
class Dry::Transformer::Pipe
  extend ::Dry::Transformer::Pipe::ClassInterface

  # Execute the transformation pipeline with the given input.
  #
  # @api public
  # @example
  #
  #   class SymbolizeKeys < Dry::Transformer
  #   symbolize_keys
  #   end
  #
  #   SymbolizeKeys.new.call('name' => 'Jane')
  #   # => {:name=>"Jane"}
  # @param input [mixed] The input to pass to the pipeline
  # @return [mixed] output The output returned from the pipeline
  #
  # source://dry-transformer//lib/dry/transformer/pipe.rb#68
  def call(input); end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/pipe.rb#50
  def transproc; end
end

# @api public
#
# source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#9
module Dry::Transformer::Pipe::ClassInterface
  # Return a base Dry::Transformer class with the
  # container configured to the passed argument.
  #
  # @api public
  # @example
  #
  #   class MyTransformer < Dry::Transformer[Transproc]
  #   end
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [subclass of Dry::Transformer]
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#27
  def [](container); end

  # Get or set the container to resolve transprocs from.
  #
  # @api private
  # @example
  #
  #   # Setter
  #   Dry::Transformer.container(Transproc)
  #   # => Transproc
  #
  #   # Getter
  #   Dry::Transformer.container
  #   # => Transproc
  # @param container [Transproc::Registry] The container to resolve transprocs from
  # @return [Transproc::Registry]
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#60
  def container(container = T.unsafe(nil)); end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#74
  def define!(&block); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#11
  def dsl; end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#69
  def import(*args); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#34
  def inherited(subclass); end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#81
  def new(*_arg0, **_arg1); end

  # Get a transformation from the container,
  # without adding it to the transformation pipeline
  #
  # @api public
  # @example
  #
  #   class Stringify < Dry::Transformer
  #   map_values t(:to_string)
  #   end
  #
  #   Stringify.new.call(a: 1, b: 2)
  #   # => {a: '1', b: '2'}
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Transproc::Function]
  #
  # source://dry-transformer//lib/dry/transformer/pipe/class_interface.rb#109
  def t(fn, *args); end
end

# @api public
#
# source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#9
class Dry::Transformer::Pipe::DSL
  # @api private
  # @return [DSL] a new instance of DSL
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#17
  def initialize(container, ast: T.unsafe(nil), &block); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#14
  def ast; end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#34
  def call(transformer); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#11
  def container; end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#29
  def dup; end

  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#24
  def t(name, *args); end

  private

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#51
  def method_missing(meth, *args, &block); end

  # @api private
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#41
  def node(&block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-transformer//lib/dry/transformer/pipe/dsl.rb#46
  def respond_to_missing?(method, _include_private = T.unsafe(nil)); end
end

# Transformation functions for Procs
#
# @api public
# @example
#   require 'ostruct'
#   require 'dry/transformer/proc'
#
#   include Dry::Transformer::Helper
#
#   fn = t(
#   :map_value,
#   'foo_bar',
#   t(:bind, OpenStruct.new(prefix: 'foo'), -> s { [prefix, s].join('_') })
#   )
#
#   fn["foo_bar" => "bar"]
#   # => {"foo_bar" => "foo_bar"}
#
# source://dry-transformer//lib/dry/transformer/proc_transformations.rb#23
module Dry::Transformer::ProcTransformations
  extend ::Dry::Transformer::Registry

  class << self
    # Change the binding for the given function
    #
    # @api public
    # @example
    #   Dry::Transformer(
    #   :bind,
    #   OpenStruct.new(prefix: 'foo'),
    #   -> s { [prefix, s].join('_') }
    #   )['bar']
    #   # => "foo_bar"
    # @param [Proc]
    # @return [Proc]
    #
    # source://dry-transformer//lib/dry/transformer/proc_transformations.rb#41
    def bind(value, binding, fn); end
  end
end

# Recursive transformation functions
#
# @api public
# @example
#   require 'dry/transformer/recursion'
#
#   include Dry::Transformer::Helper
#
#   fn = t(:hash_recursion, t(:symbolize_keys))
#
#   fn["name" => "Jane", "address" => { "street" => "Street 1" }]
#   # => {:name=>"Jane", :address=>{:street=>"Street 1"}}
#
# source://dry-transformer//lib/dry/transformer/recursion.rb#18
module Dry::Transformer::Recursion
  extend ::Dry::Transformer::Registry

  class << self
    # Recursively apply the provided transformation function to an array
    #
    # @api public
    # @example
    #   Dry::Transformer(:array_recursion, -> s { s.compact })[
    #   [['Joe', 'Jane', nil], ['Smith', 'Doe', nil]]
    #   ]
    #   # =>  [["Joe", "Jane"], ["Smith", "Doe"]]
    # @param [Array]
    # @return [Array]
    #
    # source://dry-transformer//lib/dry/transformer/recursion.rb#85
    def array_recursion(value, fn); end

    # Recursively apply the provided transformation function to a hash
    #
    # @api public
    # @example
    #   Dry::Transformer(:hash_recursion, Dry::Transformer(:symbolize_keys))[
    #   ["name" => "Jane", "address" => { "street" => "Street 1", "zipcode" => "123" }]
    #   ]
    #   # =>  {:name=>"Jane", :address=>{:street=>"Street 1", :zipcode=>"123"}}
    # @param [Hash]
    # @return [Hash]
    #
    # source://dry-transformer//lib/dry/transformer/recursion.rb#107
    def hash_recursion(value, fn); end

    # Recursively apply the provided transformation function to an enumerable
    #
    # @api public
    # @example
    #   Dry::Transformer(:recursion, Dry::Transformer(:is, ::Hash, Dry::Transformer(:symbolize_keys)))[
    #   {
    #   'id' => 1,
    #   'name' => 'Jane',
    #   'tasks' => [
    #   { 'id' => 1, 'description' => 'Write some code' },
    #   { 'id' => 2, 'description' => 'Write some more code' }
    #   ]
    #   }
    #   ]
    #   => {
    #   :id=>1,
    #   :name=>"Jane",
    #   :tasks=>[
    #   {:id=>1, :description=>"Write some code"},
    #   {:id=>2, :description=>"Write some more code"}
    #   ]
    #   }
    # @param [Enumerable]
    # @return [Enumerable]
    #
    # source://dry-transformer//lib/dry/transformer/recursion.rb#54
    def recursion(value, fn); end
  end
end

# @api public
#
# source://dry-transformer//lib/dry/transformer/recursion.rb#23
Dry::Transformer::Recursion::IF_ARRAY = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://dry-transformer//lib/dry/transformer/recursion.rb#21
Dry::Transformer::Recursion::IF_ENUMERABLE = T.let(T.unsafe(nil), Proc)

# @api public
#
# source://dry-transformer//lib/dry/transformer/recursion.rb#25
Dry::Transformer::Recursion::IF_HASH = T.let(T.unsafe(nil), Proc)

# Container to define transproc functions in, and access them via `[]` method
# from the outside of the module
#
# @api public
# @example
#   module FooMethods
#   extend Dry::Transformer::Registry
#
#   def self.foo(name, prefix)
#   [prefix, '_', name].join
#   end
#   end
#
#   fn = FooMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   module BarMethods
#   extend FooMethods
#
#   def self.bar(*args)
#   foo(*args).upcase
#   end
#   end
#
#   fn = BarMethods[:foo, 'baz']
#   fn['qux'] # => 'qux_baz'
#
#   fn = BarMethods[:bar, 'baz']
#   fn['qux'] # => 'QUX_BAZ'
#
# source://dry-transformer//lib/dry/transformer/registry.rb#35
module Dry::Transformer::Registry
  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Dry::Transformer::Function]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#48
  def [](fn, *args); end

  # Returns wether the registry contains such transformation by its key
  #
  # @api public
  # @param key [Symbol]
  # @return [Boolean]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#63
  def contain?(key); end

  # Gets the procedure for creating a transproc
  #
  # @api public
  # @param fn [#call, Symbol] Either the procedure, or the name of the method of the current module,
  #   or the registered key of imported procedure in a store.
  # @return [#call]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#134
  def fetch(fn); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#112
  def import(*args); end

  # store.register(:to_json) { |v| v.to_json }
  #
  # @api public
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#74
  def register(name, fn = T.unsafe(nil), &block); end

  # The store of procedures imported from external modules
  #
  # @api public
  # @return [Dry::Transformer::Store]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#122
  def store; end

  # Builds the transformation
  #
  # @api public
  # @param fn [Proc, Symbol] A proc, a name of the module's own function, or a name of imported
  #   procedure from another module
  # @param args [Object, Array] Args to be carried by the transproc
  # @return [Dry::Transformer::Function]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#48
  def t(fn, *args); end

  # Imports either a method (converted to a proc) from another module, or
  # all methods from that module.
  #
  # If the external module is a registry, looks for its imports too.
  #
  # @api public
  # @overload import
  # @overload import
  # @overload import
  # @return [itself] self
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#112
  def uses(*args); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-transformer//lib/dry/transformer/registry.rb#145
  def already_wrapped?(func); end
end

# Immutable collection of named procedures from external modules
#
# @api private
#
# source://dry-transformer//lib/dry/transformer/store.rb#9
class Dry::Transformer::Store
  # source://dry-transformer//lib/dry/transformer/store.rb#25
  def initialize(methods = T.unsafe(nil)); end

  # source://dry-transformer//lib/dry/transformer/store.rb#46
  def contain?(key); end

  # source://dry-transformer//lib/dry/transformer/store.rb#36
  def fetch(key); end

  # source://dry-transformer//lib/dry/transformer/store.rb#65
  def import(*args); end

  # @api private
  # @return [Hash] The associated list of imported procedures
  #
  # source://dry-transformer//lib/dry/transformer/store.rb#14
  def methods; end

  # source://dry-transformer//lib/dry/transformer/store.rb#57
  def register(name, fn = T.unsafe(nil), &block); end

  protected

  # source://dry-transformer//lib/dry/transformer/store.rb#119
  def import_all(source); end

  # source://dry-transformer//lib/dry/transformer/store.rb#90
  def import_method(source, name, new_name = T.unsafe(nil)); end

  # source://dry-transformer//lib/dry/transformer/store.rb#107
  def import_methods(source, names); end
end

# source://dry-transformer//lib/dry/transformer/constants.rb#5
Dry::Transformer::Undefined = T.let(T.unsafe(nil), Object)
